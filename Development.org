* Jt808 development
#+BEGIN_SRC shell
gmake clean run-broker
./scripts/test.sh
/Volumes/Kayle/w/rabbitmq/rabbitmq-tutorials/erlang/emit_log_topic.erl
/Volumes/Kayle/w/rabbitmq/rabbitmq-tutorials/erlang/receive_logs_topic.erl "#"
#+END_SRC

* Jt808 devlopment client
#+BEGIN_SRC shell
# mqtt connect package
export DATA=102300064D51497364700302003C00156D6F73717075627C31353235382D6D6F7267616E61
# jt808 hello
export DATA=3E002A000D201806011200000168656C6C6F2C20383038213D013D027C3E
# connect(login)
export DATA=3E01030058201805141800000C313338393630373935323700006875776F2D6A743830382D65726C616E672D636C69656E7400006775657374000067756573740000026950686F6E6520334700003230312E312E312D6875776F00004F53582031300000012B3E
# unknown jt808 frame
export DATA=3E002A002C20180514180000018368036400186875776F5F6A743830385F6672616D655F756E6B6E6F776E6B000578696E79696B00036C6565F03E
# TODO connect && foo
export DATA=3E01030058201805141800000C313338393630373935323700006875776F2D6A743830382D65726C616E672D636C69656E7400006775657374000067756573740000026950686F6E6520334700003230312E312E312D6875776F00004F53582031300000012B3E3E002A002C20180514180000018368036400186875776F5F6A743830385F6672616D655F756E6B6E6F776E6B000578696E79696B00036C6565F03E
cat <(echo $DATA | xxd -r -p ) - | nc localhost 8898
#+END_SRC

* Docker
gmake clean dist
mv ./plugins/rabbitmq_jt808-3.7.0*.ez ./plugins/rabbitmq_jt808-3.7.0.ez
docker-compose build

* Jt808
1. 服务器响应消息头中的手机号码和请求的手机号码一致。例如：
   - 客户端心跳包：7E000200000 13200000003 0003317E
   - 服务端响应包: 7E800100050 13200000003 00040003000200B17E

2. JT808 收到的消息，会发送到 {exchange=amq.topic, type=topic}
   - 0x0102 鉴权消息，鉴权码会发到 routing_key=auth. 消息格式为
     #+BEGIN_SRC erlang
<<"auth">>:<<"13200000003:1234567890A">>
     #+END_SRC
   - 0x0002 心跳消息，不发送到队列
   - 其它消息，将消息原样转发到 routing_key=jt808

3. 队列消费代码实例：
   #+BEGIN_SRC erlang
-include_lib("amqp_client/include/amqp_client.hrl").

main(Argv) ->
    {ok, Connection} =
        amqp_connection:start(#amqp_params_network{host = "localhost"}),
    {ok, Channel} = amqp_connection:open_channel(Connection),

    amqp_channel:call(Channel, #'exchange.declare'{exchange = <<"amq.topic">>,
                                                   durable=true,
                                                   type = <<"topic">>}),

    #'queue.declare_ok'{queue = Queue} =
        amqp_channel:call(Channel, #'queue.declare'{exclusive = true,
                                                    durable=true}),

    [amqp_channel:call(Channel, #'queue.bind'{exchange = <<"amq.topic">>,
                                              routing_key = list_to_binary(BindingKey),
                                              queue = Queue})
     || BindingKey <- Argv],

    io:format(" [*] Waiting for logs. To exit press CTRL+C~n"),

    amqp_channel:subscribe(Channel, #'basic.consume'{queue = Queue,
                                                     no_ack = true}, self()),
    receive
        #'basic.consume_ok'{} -> ok
    end,
    loop(Channel).

loop(Channel) ->
    receive
        {#'basic.deliver'{routing_key = RoutingKey}, #amqp_msg{payload = Body}} ->
            io:format(" [x] ~p:~p~n", [RoutingKey, Body]),
            loop(Channel)
    end.
   #+END_SRC
